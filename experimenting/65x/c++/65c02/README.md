# 65C02 emulator

*Copyright Â© Faustic Inferno SL*

*Licensed under the MIT License*

## Implementation for C++

### Test machine

#### Previous work

The implementation for Java and the implementation for Javascript were made before the implementation for C++. The implementation for C++ is mostly based on the implementation for Java, but some things are done a bit differently. Some changes only make sense in C++, but others should probably get into the implementation for Java if a future revision is made.

Like in Java, we separate the concepts of parser and processor. The parser reads each instructions and, unlike what we did in Java, also reads its parameters, and then calls the processor to do the actual operation.

#### Parser

There is a class `Parser` to parse instructions. It parses the 65816 instruction set, which is a superset of the 6502 instruction set, so it also allows parsing of the 6502 instruction set and the original 65C02 instruction set, which did not include Rockwell additional instructions.

The parser has the following limitations:

* It knows nothing about Rockwell additions. Rockwell-compatible chips can still be emulated, but parsing must partially be done within the processor part.
* It is not aware of the value of the `m` flag, which affects the length of instructions that use immediate addressing mode. The parser always assumes `m == 1`. If the assumption is not correct, it needs to be corrected within the processor part.
* The parser does not know when to jump or branch. However, it can be informed that a jump or branch has taken place to resume parsing at a different address.

Internally, the parser uses a different function to process each opcode, which is used as an index into an array of 256 function pointers. This makes the function selection more compact and legible than if a huge `switch` block were used instead. Intuitively, it seems likely to be also faster, but maybe that's not the case, depending on how well the optimizer deals with `switch` blocks.

Operation of the parser is very simple:

* When the parser is created, it gets a reference to the processor that will process the instructions, and a reference to the memory where the instructions are stored. The owner of the `Parser` object must ensure that no more parsing is done after those references are no longer valid.
* The parser has a program counter. The user of the `Parser` object can read the program counter through a getter function and can change it using a function named `jmp`.
* The parser has a number of internal registers (different from the 65C02 data registers) to hold instruction parameters. The user of the `Parser` object can read the values in this registers through corresponding getter functions.

#### Processor

There is a virtual class `Processor` that can process the instructions parsed by the parser. Each derived class can represent a different processor of the 65x family (6502, 65C02, 65816...), as well as a related service (disassembler, dynamically-compiled emulator, flag usage predictor...).

Processing might be faster if we make `Parser` a template with a `Processor` parameter that is not necessarily a virtual class. Converting `Parser` into a template should not be difficult and it may be done in the future, but the current way is easier and seems enough for now.

#### CPU

There is a class `Cpu65c02` derived from `Processor`. It is the owner and user of a `Parser` object.

A `Cpu65c02` object emulates a 65C02 microprocessor. CPU instructions are interpreted as they are parsed by the parser.

The `Cpu65c02` object contains a reference to the emulated memory connected to the emulated CPU. The owner of the `Cpu65c02` object must ensure that no more memory accesses are done after that reference is no longer valid.

The `Cpu65c02` object has its own program counter. When an instruction starts being processed, the parser program counter already points to the following instruction, while the `Cpu65c02` program counter still points to the current instruction. This is useful for debugging and it also makes it easier to correct the parsing made by the parser.

#### Machine

There is a class `Test_machine`. It is the owner and user of a `Cpu65c02` object. It is also the owner of a `Mem_test` object that represents the memory connected to the `Cpu65c02` object.

### Auxiliary tools

Some of the auxiliary tools that are part of the implementation for Java have not been implemented for C++ yet:

* Test generator: not needed for now. We use the tests generated by the Java version.
* 65C02 assembler: partly done, just what is required to generate the minimum interrupt handling code we need.
* 65C02 disassembler: it will probably be implemented in the future, but we haven't needed it yet.

