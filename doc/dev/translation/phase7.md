# Fauces

*Copyright © Faustic Inferno SL*

*Licensed under the MIT License*

## Phases of translation

### Phase 7

The sequence of preprocessing tokens becomes a sequence of tokens, which is translated. The result of the translation is a translated translation unit.

This phase contains most of the architecture dependence, when machine code is generated. As the program is analysed for translation and lengthy expressions are divided into smaller parts while making as many compile-time evaluations as possible, sooner or later our translator will reach a point where it needs to generate some machine code. To this end, it will make use of a code generator.

#### Code generators

The most abstract code generator is simply an interface (implicit or explicit) providing a function prototype for every kind of C++ statement or expression that may result in machine code generation. We will also label as abstract any partial implementation of such interface.

To keep portability to a maximum, our idea is to use an abstract code generator that implements most operations in an architecture-independent way in terms of a few simple operations, which are left unimplemented. Once the abstract code generator is done, we only need to implement these few operations for the desired architecture, so we expect to be able to develop in little time a minimal code generator, which will probably be very slow but fully functional. Starting from this point, which we may consider a negative optimisation level, we can go on overriding architecture-independent operations with native code until we reach a reasonably fast optimisation level 0 and further optimisation levels.

    Abstract code generator ⟵ Minimal code generator ⟵ Level 0 code generator
                            ↖︎           ↑               ↗︎
                              Optimised code generators

From the point of view of the translator, a code generator is just its interface. This means the translator knows nothing about how the code generator is implemented.

##### Architecture-independent implementation

Once we have decided that there will be an abstract code generator that will implement most operations in terms of a few select operations, we need to decide how this will be done in practice. We believe that the code that implements an operation in terms of other operations will be easier to maintain if it is mostly done as part of the language library.

For example, if we want to implement signed integer multiplication, we will leave this task to a function like `int __signed_multiply(int, int)`. The abstract code generator will just tell itself to generate a call to that function. Of course, the abstract code generator does not know how to generate a call to a function, because calling a function is an architecture-dependent operation. So this call will actually be generated by whatever concrete code generator is inheriting from the abstract one.

In order for this to work, we need to link the language library with the program being translated. Functions in the language library intended to implement an operation in terms of simpler operations should be written without architecture dependencies whenever possible; otherwise, we will need to rewrite them for each architecture that does not meet the original assumptions.

##### Architecture-dependent implementations

Concrete code generators are architecture-dependent and generate the actual machine code needed by the translator. Whenever we start supporting a new architecture, we need to implement at least one concrete code generator. Until the C++ translator is feature-complete, we will encounter more often the need to start supporting a new operation for any architectures.

###### Supporting a new architecture

1. Minimal code generator: implement the minimum set of operations required by the abstract code generator; we expect the rest of operations will automatically work when inheriting from the architecture-independent partial implementation, once the language library is available.
2. Language library: using the minimal code generator, build the language library for the new architecture; the library may be rebuilt later with improved code generators.
3. Level 0 code generator: inherit from the minimal code generator, which may be kept around for comparison purposes; then override operations for which the new architecture provides explicit instructions or that might be otherwise improved even if the new architecture does not provide explicit instructions for them. Optimisation level 0 may impose some restrictions preventing the generated code to be optimal from a performance point of view. Those restrictions, if any, will be specified in due time.
4. Optimised  code generators: inherit from level 0 code generator; then override the operations that have room for improvement without the restrictions that might be imposed by level 0.

###### Supporting a new operation

1. Code generator interface: add a new function prototype to the interface representing the new operation
2. Language library: if the new operation can be implemented in terms of previously defined operations, add the corresponding function to the language library.
3. Architecture-independent code generator: if the new operation has a corresponding function in the language library, implement the new operation by generating a call to that function.
4. Minimal code generator: if the new operation is not implemented in the architecture-independent code generator, implement it in the minimal code generator for each supported architecture.
5. Language library: rebuild the language library for each supported architecture.
6. Level 0 code generator: for each supported architecture, check if the new operation might benefit from an architecture-dependent optimisation within level 0 restrictions.
7. Optimised  code generators: for each supported architecture, check if the new operation might benefit from an architecture-dependent optimisation free of level 0 restrictions.

##### Essential operations

We label as essential those operations that the minimal code generator is required to implement. We can stipulate early which operations we consider essential. Getting them wrong in the beginning is not too bad: if we forget about an essential operation, we can still add it when the need for it becomes apparent; if we inadvertently define as essential an operation that could have been implemented in terms of others, our minimal code generator will simply have a little more architecture-dependent code than was needed.

We will choose essential operations based on the following ideas:

* We can implement floating point arithmetic from unsigned integer arithmetic. This may be needed not only to save effort for the minimal code generator, but also for architectures lacking FPU.
* We can implement signed integer arithmetic from unsigned integer arithmetic. This may be needed not only to save effort for the minimal code generator, but also for architectures that do not implement two's complement signed arithmetic, required by recent versions of the C++ standard.
* We can implement unsigned integer multiplicative operations from unsigned integer additive operations and shift operations. This may be needed not only to save effort for the minimal code generator, but also for architectures lacking instructions for multiplication and division.
* We can implement unsigned additive operations from bitwise operations and shift operations. This is somewhat extravagant, because the only architecture we are likely to find lacking addition and subtraction instructions is our own virtual architecture. But those are also two instructions that the minimal code generator will not have to implement.
* We can implement all bitwise operations from one's complement and AND operations. Again, there are probably no real architectures that would benefit from this, but the minimal code generator will be done faster.
* We can implement all operations for an unsigned integer of a certain size from the operations for an unsigned integer of bigger or smaller size.

