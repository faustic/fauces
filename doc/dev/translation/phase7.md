# Fauces

*Copyright © Faustic Inferno SL*

*Licensed under the MIT License*

## Phases of translation

### Phase 7

The sequence of preprocessing tokens becomes a sequence of tokens, which is translated. The result of the translation is a translated translation unit.

This phase contains most of the architecture dependence, when machine code is generated. As the program is analysed for translation and lengthy expressions are divided into smaller parts while making as many compile-time evaluations as possible, sooner or later our translator will reach a point where it needs to generate some machine code. To this end, it will make use of a code generator.

#### Code generators

The most abstract code generator is simply an interface (implicit or explicit) providing a function prototype for every kind of C++ statement or expression that may result in machine code generation. We will also label as abstract any partial implementation of such interface.

To keep portability to a maximum, our idea is to use an abstract code generator that implements most operations in an architecture-independent way in terms of a few simple operations, which are left unimplemented. Once the abstract code generator is done, we only need to implement these few operations for the desired architecture, so we expect to be able to develop in little time a minimal code generator, which will probably be very slow but fully functional. Starting from this point, which we may consider a negative optimisation level, we can go on overriding architecture-independent operations with native code until we reach a reasonably fast optimisation level 0 and further optimisation levels.

    Abstract code generator ⟵ Minimal code generator ⟵ Level 0 code generator
                            ↖︎           ↑               ↗︎
                              Optimised code generators

From the point of view of the translator, a code generator is just its interface. This means the translator knows nothing about how the code generator is implemented.

##### Architecture-independent implementation

Once we have decided that there will be an abstract code generator that will implement most operations in terms of a few select operations, we need to decide how this will be done in practice. We believe that the code that implements an operation in terms of other operations will be easier to maintain if it is mostly done as part of the language library.

For example, if we want to implement signed integer multiplication, we will leave this task to a function like `int __signed_multiply(int, int)`. The abstract code generator will just tell itself to generate a call to that function. Of course, the abstract code generator does not know how to generate a call to a function, because calling a function is an architecture-dependent operation. So this call will actually be generated by whatever concrete code generator is inheriting from the abstract one.

In order for this to work, we need to link the language library with the program being translated. Functions in the language library intended to implement an operation in terms of simpler operations should be written without architecture dependencies whenever possible; otherwise, we will need to rewrite them for each architecture that does not meet the original assumptions.

##### Architecture-dependent implementations

Concrete code generators are architecture-dependent and generate the actual machine code needed by the translator. Whenever we start supporting a new architecture, we need to implement at least one concrete code generator. Until the C++ translator is feature-complete, we will encounter more often the need to start supporting a new operation for any architectures.

###### Supporting a new architecture

1. Minimal code generator: implement the minimum set of operations required by the abstract code generator; we expect the rest of operations will automatically work when inheriting from the architecture-independent partial implementation, once the language library is available.
2. Language library: using the minimal code generator, build the language library for the new architecture; the library may be rebuilt later with improved code generators.
3. Level 0 code generator: inherit from the minimal code generator, which may be kept around for comparison purposes; then override operations for which the new architecture provides explicit instructions or that might be otherwise improved even if the new architecture does not provide explicit instructions for them. Optimisation level 0 may impose some restrictions preventing the generated code to be optimal from a performance point of view. Those restrictions, if any, will be specified in due time.
4. Optimised  code generators: inherit from level 0 code generator; then override the operations that have room for improvement without the restrictions that might be imposed by level 0.

###### Supporting a new operation

1. Code generator interface: add a new function prototype to the interface representing the new operation
2. Language library: if the new operation can be implemented in terms of previously defined operations, add the corresponding function to the language library.
3. Architecture-independent code generator: if the new operation has a corresponding function in the language library, implement the new operation by generating a call to that function.
4. Minimal code generator: if the new operation is not implemented in the architecture-independent code generator, implement it in the minimal code generator for each supported architecture.
5. Language library: rebuild the language library for each supported architecture.
6. Level 0 code generator: for each supported architecture, check if the new operation might benefit from an architecture-dependent optimisation within level 0 restrictions.
7. Optimised  code generators: for each supported architecture, check if the new operation might benefit from an architecture-dependent optimisation free of level 0 restrictions.

##### Essential operations

We label as essential those operations that the minimal code generator is required to implement. We can stipulate early which operations we consider essential and we may later revise this requirement if more convenient choices become apparent during development.

